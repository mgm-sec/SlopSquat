# Minimal npm Supply-Chain PoC

This demonstrates a **minimal npm supply-chain PoC** showing that a dependency can execute code in a random npm app:

1. **At install time** (`postinstall`)  
2. **At runtime** simply by being imported via `require()`  

Execution occurs implicitly via package installation or module loading.  

---

## ‚ö†Ô∏è Threat Model

An attacker publishes a package that:  

- Looks legitimate  
- Executes code during `npm install`  
- Executes code again when loaded by Node.js  

This PoC uses `cookie-session-es6` to demonstrate both behaviors.  

---

## üì¶ Install-Time Execution

### Default behavior (unsafe)

```bash
npm install cookie-session-es6
```
Output:

```yaml
üö® INSTALL SCRIPT EXECUTED: Beware of slopsquatting üö®
```
This confirms execution of a postinstall script.

Disable install scripts (mitigation)
```bash
npm install cookie-session-es6 --ignore-scripts=true
```

---

## ‚úî Package installs

‚ùå Install-time code does not execute

## üîß Npm Config Hardening
Check relevant settings:

```bash
npm config get ignore-scripts
npm config get unsafe-perm
```

Mitigate globally if needed:

```bash
npm config set ignore-scripts true
npm config set unsafe-perm false
```

‚ö†Ô∏è By default, npm does not display scripts in a dependency. Manual inspection of package.json is mandatory before installing any package.

‚öôÔ∏è Runtime Execution via require()
index.js (relevant line)

```js
require("cookie-session-es6");
```
Why this is dangerous:

1. require() executes all top-level code immediately
2. No function calls are required
3. Execution happens even if exports are unused

‚û°Ô∏è Importing a package is equivalent to executing it

---

## ‚ñ∂Ô∏è Running the PoC
```bash
npm start
```
Output:

```bash

‚ö†Ô∏è Beware of slopsquatting

Server running on http://localhost:3000
```
The warning appears solely because of require().

---

## üö´ Mitigating Runtime Execution
Node.js does not have a global ‚Äúsafe import‚Äù mode. Mitigations are layered.

### 1Ô∏è‚É£ Avoid importing untrusted packages (most effective)
Remove unused dependencies

Remove unused require() / import statements

Treat unused imports as a security bug



### 2Ô∏è‚É£ Node.js Policy Files (optional but strong)
Node.js policy files (--experimental-policy) can restrict which modules are allowed to load or execute.

Implications:

1. Only modules explicitly allowed by the policy can run
2. Other modules will fail to execute on require()
3. Functions or exports that are actually used in your code can still be used if allowed in the policy
4. Blocking a module entirely prevents any top-level code execution, so policy granularity is key
5. Example: block the malicious package completely:

```json
// policy.json
{
  "resources": {
    "node_modules/cookie-session-es6/*": {
      "integrity": false
    }
  }
}
```

Run Node.js with:

```bash
node --experimental-policy=policy.json index.js
```
‚úî Prevents top-level code from running

‚ö†Ô∏è Experimental but effective

‚ö†Ô∏è Any require of cookie-session-es6 will now fail, so only use for packages you want to fully block

### 3Ô∏è‚É£ Sandbox Execution (advanced)
Use Node.js vm or vm2 modules to run untrusted code in isolation

Example: load a plugin safely:

```js
const { NodeVM } = require('vm2');
const vm = new NodeVM({ sandbox: {}, require: { external: true } });
vm.run(`module.exports = require('cookie-session-es6');`);
```
‚ö†Ô∏è Code inside the VM cannot access your main app‚Äôs globals

Useful for plugins or third-party modules that you need but don‚Äôt fully trust

### 4Ô∏è‚É£ Bundle-Time Elimination
If using a bundler like Webpack/Rollup:

Tree-shake unused imports:

```js
import { safeFunction } from 'some-lib'; // unused parts are removed
```

Fail builds on side-effectful modules:

```json
// package.json
{
  "sideEffects": false
}
```
‚ö†Ô∏è Only set "sideEffects": false if verified‚Äîsome modules may run code on import

Purpose: prevents top-level code from executing in production bundles for unused modules.

---

## üß® All Relevant Execution Entry Points
Install-Time:

1. preinstall, install, postinstall, prepare
2. Runtime (Node.js):
3. require("pkg"), import "pkg"
4. Package main / exports
5. Top-level module code
6. Transitive dependencies
7.NODE_OPTIONS=--require pkg
8.CLI binaries via bin
9. Tooling / Environment:
10. Test runners auto-loading dependencies
11. Dev tools (nodemon, jest, ts-node)
12. Bundlers evaluating modules at build time

‚û°Ô∏è Every dependency is executable code.

---

## üß† Security Takeaways
npm install is a code execution event

1. require() / import is also a code execution event
2. Disabling install scripts is necessary but insufficient
3. Runtime controls must be explicit and enforced
4. Unused dependencies are a real attack surface
5. Manual review of package.json and scripts is mandatory

npm default behavior hides scripts, so inspection cannot be skipped


---

## ‚úÖ Actionable Terminal-Ready Checklist
Check current npm and Node.js settings:

```bash
npm config get ignore-scripts
npm config get unsafe-perm
echo $NODE_OPTIONS
```

Mitigate install-time risks:

```bash
npm config set ignore-scripts true
npm config set unsafe-perm false
npm install <package> --ignore-scripts=true
```

Check for scripts in a package before install:

```bash
npm view <package> scripts
```
Check for postinstall scripts in local node_modules:

```bash
find node_modules -name package.json -exec grep -H '"postinstall"' {} \;
```

Audit and remove unused dependencies:

```bash
npm ls --prod --parseable | xargs -n1 basename | sort
npm uninstall <unused-package>
```

Apply Node.js policy (experimental, blocks unsafe modules):

```bash
# create policy.json
echo '{"resources":{"node_modules/cookie-session-es6/*":{"integrity":false}}}' > policy.json
# run Node with policy
node --experimental-policy=policy.json index.js
```

Bundle-time hardening (if using Webpack/Rollup):

```json
// package.json
{
  "sideEffects": false
}
```
Tree-shake unused imports to remove side-effectful code

---

## üìå Purpose
This PoC exists to:

1.Demonstrate real npm supply-chain risk
2. Show the difference between install-time and runtime execution
3. Emphasize that importing a package is not benign
4. Provide actionable mitigations

---

## ‚öñÔ∏è Disclaimer
For educational and defensive security research only.

